doc
* docdocmanifest.txt
<document>
<id>1000</id> 
<group>1000</group> 
<timestamp>51</timestamp>
<title>doc/manifest.txt</title>
<body>
 
This document describes manifest for ZeroVM NaCl application.
update: a new design
-------------------------------------------------------------


Description:
The manifest is a text file which must be provided in order to run a NaCl application inside ZeroVM. 
Manifest samples can be found in "samples" directory.

list of available keywords:
Version
Nexe
Channel
MemMax
Timeout
NodeName
NexeEtag
NameServer
Environment (will deprecated soon)
CommandLine (will deprecated soon)

Structure:
- each valid line must contain exactly only one key and value(s) separated by exactly one '=' sign
- both key and value may contain spaces
- key and value case does matter: "key" and "KeY" are treated as a different keywords
- spaces around keyvalue will be ignored
- lines are delimited with EOL (unix or windows style)
- invalid lines will be ignored
- lines with unknown keywords (not mentioned below) will be ignored
- some keywords expects complex values: comma separated values. for example, "Environment"

List of valid keywords:
NameServer
  (pseudo url)
  the address of name server. name server resolves zerovm provided network channels.
  only supported protocol is udp. notation used to specify the address is not standard
  since 1. it is internal thing, 2. it is more simple to parse such pseudo url. the
  same notation used for network channels.
  NameServer = udp:127.0.0.1:54321
  udp - protocol
  127.0.0.1 - server ip address
  54321 - server port
  note: it is possible to use integer ip representation instead of IPv4
  
Channel
  (obligatory, 7 comma separated values)
  Description of a channel. The order does matter. example:
  Channel = homedazogitzerovmsamplessortsort.stdout.log, devstdout, 5, 0, 0, 99999999, 99999999
  where: 
    [1] trusted channel name (na for the user), 
    [2] untrusted channel name, 
    [3] access type, 
    [4] gets limit, 
    [5] get size limits, 
    [6] puts limit, 
    [7] put size limits
  Each manifest SHOULD have at least three Channel configuration entries for the standard devices: stdin, stdout, stderr
  Example (maps all channels to devnull):
    Channel = devnull, devstdin, 0, 0, 0, 0, 0
    Channel = devnull, devstdout, 0, 0, 0, 0, 0
    Channel = devnull, devstderr, 0, 0, 0, 0, 0
  network channels has same fields, but the very 1st one (trusted channel name) has special form:
  protocol:address:port
  where
    protocol can be tcp (or udp for name server)
    address is IPv4 or integer representaion of it
    port is 16 bit integer or empty (if name server used)
  
Environment
  (comma separated values, will be deprecated soon)
  expects comma separated pairs: key, value. example:
  Environment = TimeStamp, 1337012520, ContentType, utf-8
Version
  (obligatory, single value)
  currently ZeroVM is not backward compatible with the older manifest versions.
  working version is 09082012
Nexe
  (obligatory, single value)
  NaCl module to isolate and run, full path
NexeEtag
  (single value)
  reserved
Timeout
  (obligatory, single value)
  time out in seconds. ZeroVM will stop user program and exit after the specified period
MemMax
  (single value)
  Specifies the memory size in bytes available for the user program. If specified
  ZeroVM will allocate all memory before nexe start and will not use real memory
  allocation syscalls due nexe runtime. MemMax should take in account that 16mb should be
  reserved for the user stack, 1mb+ - for nexe code and data, and some memory for system area
CommandLine
  (space separated values, will be deprecated soon)
  command line arguments for nexe
NodeName
  (2 comma separated values)
  Specifies the node name (available for the untrusted code) and node id (not available 
  for the untrusted code). The node id should be 32-bit unsigned integer.
  Example:
  NodeName = loner, 1

Both keywords and values have size limit of 64kb. The manifest file size limited
to 0x100000. The limitations can be changed in the future.
 

</body>
</document>
 
docname_server.txt
<document>
<id>1001</id> 
<group>1001</group> 
<timestamp>55</timestamp>
<title>doc/name_server.txt</title>
<body>
 
Name server description
-----------------------

Name server is used by zerovm instances to resolve host identifiers into ip:port pairs.
To read more about host identifiers consult channels.txt manual.
Name server daemon or service is run before launching all zerovm clustered instances and is shut down after all zerovm instances exit.
The number of zerovm instances in cluster must be known before launch.
Name server must be launched on specific port and with number of instances supplied in one way or another.
In the reference implementation name server gets port number and the number of instances on the command line.
Name server uses UDP packets.
The request packet looks like this (all numbers are big endian):
4 bytes: my host identifier, integer
4 bytes: count of listen sockets in the array, integer
array of 10 byte values:
- 4 bytes: incoming connecion host identifier, integer
- 4 bytes: zero, reserved
- 2 bytes: port number, TCP port notation
4 bytes: count of connect sockets in the array, integer
array of 10 byte values:
- 4 bytes: outgoing connection host identifier, integer
- 6 bytes: zero, will be filled in response

The response packet looks exactly like the request packet with the second array filled up:
............
............
4 bytes: count of connect sockets in the array, integer
array of 10 byte values:
- 4 bytes: outgoing connection host identifier, integer
- 4 bytes: outgoing connection ip address, IP addrsss notation
- 2 bytes: outgoing connection tcp port, TCP port notation


Request:

|      4      |      4      |  2   |      4      |  2   |
=========================================================
| my host id  | bind count  |
---------------------------------------------------------
| incoming id | 00000000000 | port |.............|.......
---------------------------------------------------------
.......|......|.............|.............|......|.......
---------------------------------------------------------
| conn count  |
---------------------------------------------------------
| outgoing id | 000000000000000000 |.............|.......
---------------------------------------------------------
..............|..........................................
---------------------------------------------------------

Response:

|      4      |      4      |  2   |      4      |  2   |
=========================================================
| my host id  | bind count  |
---------------------------------------------------------
| incoming id | 00000000000 | port |.............|.......
---------------------------------------------------------
.......|......|.............|.............|......|.......
---------------------------------------------------------
| conn count  |
---------------------------------------------------------
| outgoing id | outgoing ip  port |.............|.......
---------------------------------------------------------
..............|.............|....................|.......
---------------------------------------------------------



</body>
</document>
 
dochow to get validator.txt
<document>
<id>1002</id> 
<group>1002</group> 
<timestamp>59</timestamp>
<title>doc/how to get validator.txt</title>
<body>
 
how to get standalone validator
(deprecated. see validator project)

1. download and install depot tools (as described in google chromium page):
   git clone https:git.chromium.orgchromiumtoolsdepot_tools.git
   export PATH="$PATH":`pwd`depot_tools
   
2. download and install subversion:
   sudo apt-get install subversion
   
3* instal install libelf-dev (not mentioned by google)
   apt-get install libelf-dev
   
4. download nacl (as described in google chromium page):
   gclient config http:src.chromium.orgnative_clienttrunksrcnative_client
   gclient sync

5. compile nacl linux 64-bit version with command line:
   .scons.py MODE=opt-linux,nacl platform=x86-64
   
6. take ~naclnative_clientscons-outopt-linux-x86-64stagingncval

warning:
current version of nacl validator allows using of RDTSC operation which violates
determinism. therefore before building ncval the patch should be applied:
srctrustedvalidatorx86ncval_reg_sfinc_illegal.c.gcov.html

 354               0 :   switch (state-cur_inst-insttype) {
 355                 :     case NACLi_RETURN:
 356                 :     case NACLi_EMMX:
 357                 :       * EMMX needs to be supported someday but isn't ready yet. *
 358                 :     case NACLi_ILLEGAL:
 359                 :     case NACLi_SYSTEM:
 360                 :     case NACLi_RDMSR:
 361                 :     case NACLi_RDTSCP:
 362                 :     case NACLi_LONGMODE:
 363                 :     case NACLi_SVM:
 364                 :     case NACLi_3BYTE:
 365                 :     case NACLi_UNDEFINED:
 366               0 :       *is_legal = FALSE;
 367               0 :       *disallows_flags |= NACL_DISALLOWS_FLAG(NaClMarkedIllegal);
insert to any place a new case:
                           case NACLi_RDTSC:  

update (2013.01.02):
 find "const uint8_t kNaClFullStop = 0xf4;" in srctrustedvalidatorx86ncval_reg_sfincvalidate_iter.c
 and after the line add folowing code:

const char kNaClRDTSC[] = {0x0f, 0x31}; * x86 RDTSC opcode *
const uint16_t kNaClRDTSC_SIZE = sizeof kNaClRDTSC; * x86 RDTSC opcode size *

 also replace original NCStubOutMem() with a new version:

void NCStubOutMem(NaClValidatorState *state, void *ptr, size_t num) {
  state-did_stub_out = TRUE;

  * d'b: only RDTSC should be replaced with NOPs *
  if(num == kNaClRDTSC_SIZE  !memcmp(ptr, kNaClRDTSC, num))
    memset(ptr, kNaClNOP, num);
  else
    memset(ptr, kNaClFullStop, num);
}

 this is a quick and dirty hack. in the future nacl validator must have own project in zerovm and 
 the code should be changed on more neat way

</body>
</document>
 
doczerovm_switches.txt
<document>
<id>1003</id> 
<group>1003</group> 
<timestamp>63</timestamp>
<title>doc/zerovm_switches.txt</title>
<body>
 
This document describes ZeroVM command line switches
----------------------------------------------------

ZeroVM command line switches:

  ZeroVM lightweight VM manager, build 2013-03-27
  Usage: manifest [-e#] [-l#] [-v#] [-sFPSQ]

   manifest load settings from manifest file
   -e level enable the data control. where levels are
      1 - channels, 2 - memory, 3 - both
   -l set a new storage limit (in Gb)
   -s skip validation
   -v level verbosity
   -F fuzz testing; quit right before starting user app
   -P disable channels space preallocation
   -Q disable platform qualification (dangerous!)
   -S disable signal handling


   -- The manifest contains a set of control data for the executable. Obligatory.
      More details about the manifest file can be found in the appropriate document on 
      github.comZeroVMZeroVM

-e -- enable etag engine to control data integrity. the level must be specified. there
      are following letag levels:
      1 - calculate etag for all channels
      2 - calculate etag for all user memory
      3 - calculate etag both for all channels and user memory

-l -- changes zerovm io hard limit. by default session only allowed to use 4gb
      value should be in gigabytes 

-s -- skips validation. used for "prevalidation" engine.

-v -- controls verbosity of information in the ZeroVM log. writes ZeroVM 
      log to "varlogsyslog". it is not recommended to use values more than 2
      possible values are 1..4

-F -- specified NaCl application will be loaded but not run. used for 
      "prevalidation" engine.

-S -- will prevent the signals handlers installation. not recommended to use.

-Q -- will skip data execution test. This switch makes it possible to run ZeroVM 
      application on a platform with no "data execution" protection.
      
-P -- if specified zerovm will not allocate space for "write" channels connected
      to local storage

examples:
  zerovm -v2 test.manifest
  starts zerovm with manifest "test.manifest" and "debug" verbosity
  
  zerovm -e2 test.manifest
  starts zerovm with manifest "test.manifest" with etagged memory
  
  zerovm -F test.manifest
  loads nexe specified in "test.manifest" and exits with validator status
</body>
</document>
 
docapi.txt
<document>
<id>1004</id> 
<group>1004</group> 
<timestamp>67</timestamp>
<title>doc/api.txt</title>
<body>
 
ATTENTION (please help!):
this document should be traslated to english as soon as possible

этот документ описывает пользовательский api zerovm

макроопределения, перечисления
------------------------------
enum AccessType - тип доступа. атрибут используется в описании каналов (см. "каналы") 
  SGetSPut - последовательное чтение и последовательная запись
  RGetSPut - произвольное чтение и последовательная запись
  SGetRPut - последовательное чтение и произвольная запись
  RGetRPut - произвольный доступ на чтение и запись.

enum IOLimits - ограничения доступа. атрибут используется в описании каналов (см. "каналы")
  GetsLimit - разрешенное количество чтений
  GetSizeLimit - количество байт которое может быть прочитано
  PutsLimit - разрешенное количество записей
  PutSizeLimit - количество байт которое может быть записано

enum TrapCalls - функции trap (см. "функции")
  TrapRead - чтение из канала
  TrapWrite - запись в канал
  TrapExit - завершение пользовательской программы

типы данных zerovm api
-----------------------
struct ZVMChannel - описание канала (см. "каналы")
  limits - ограничения канала (см. enum IOLimits)
  size - размер канала. не установлено для каналов последовательного доступа
  type - тип доступа (см. "enum AccessType")
  name - имя канала

вызовы nacl (nacl syscalls)
---------------------------
  не поддерживаются 

функции zerovm api
------------------
  в zerovm существует единственный системный вызов - trap, соответствующий нулевому адресу 
  в таблице trampoline . trap обслуживает 3 функцим (см. enum TrapCalls). для доступа 
  к этому сервису рекомендуется использовать "обертки" определенные в apizvm.h:
  
  zvm_pread(desc, buffer, size, offset)
  читает из канала с номером "desc" в область памяти "buffer" "size" байт. если канал 
  имеет произвольный доступ на чтение, "offset" указывает позицию в канале с которой 
  производится чтение. для канала последовательного доступа значение offset игнорируется.
  возвращает количество прочитанных байт, 0 - в случае конца канала или -errno при 
  возникновении ошибки (errno коды могут быть получены man errno).

  zvm_pwrite(desc, buffer, size, offset)
  пишет в канал с номером "desc" из области памяти "buffer" "size" байт. если канал 
  имеет произвольный доступ на запись "offset" указывает позицию в канале в которую 
  производится запись. для канала последовательного доступа значение offset игнорируется.
  возвращает количество записанных байт, или -errno при возникновении ошибки 
  (errno коды могут быть получены man errno).

  zvm_exit(code)
  завершает программу с указанным кодом

переменные
----------
struct UserManifest
  heap_ptr - начало доступной памяти (кучи) пользовательской программы
  heap_size - размер кучи в байтах
  stack_size - размер стека в байтах 
  channels_count - количество доступных каналов (3 канала: 0..2 доступны всегда)
  channels - массив структур доступных каналов (см. "struct ZVMChannel")
  
  пользовательской программе доступно макроопределение MANIFEST указывающее 
  на область содержащую вышеперечисленную информацию и доступную только для
  чтения.

каналы
------
  каналы реализуют файловую абстракцию над доступными zerovm средствами вводавывода. в данный
  момент это локальные файлы и сетевые соединения. количество доступных каналов неизменно для
  сеанса работы и известно сразу после инициалиции zerovm api (см. "zvm_init"). более подробную
  информацию об атрибутах каналов можно получить из "struct ZVMChannel". для обслуживания каналов
  предназначена часть функций trap (см. "функции"). гарантируется наличие 3х стандартных каналов:
  stdin, stdout, stderr.

  специальные каналы:
  stdin - стандартный ввод. канал последовательного доступа. только чтение.
          доступен по индексу 0 в MANIFES-channels
  stdout - стандартный вывод. канал последовательного доступа. только запись.
          доступен по индексу 1 в MANIFES-channels
  stderr - стандартный вывод ошибок. канал последовательного доступа. только запись.
          доступен по индексу 2 в MANIFES-channels
          
  реализована поддержка каналов следующих типов:
  - только для чтения последовательного доступа
  - только для чтения произвольного доступа
  - только для записи последовательного доступа
  - только для записи произвольного доступа
  - appendable (cdr). канал имеющий произвольный доступ на чтение и последовательный доступ
    при записи. кроме того если канал имеет ненулевую длину, начальная позиция записи
    указывает на байт следующий за последним
  - канал произвольного доступа для чтения и записи
    
  длина каналов и признак конца канала:
  для каналов произвольного доступа определена длина канала (количество байт канала), 
  описывается полем "size" (см. struct ZVMChannel). для каналов последовательного доступа
  поле "size" не определено, однако для каналов "для чтения" при достижении конца канала
  функцией zvm_pread возвращается 0
  примечание: 
  признак конца канала является специальным символом и учитывается limits. т.о.
  если через канал последовательного доступа разрешено прочесть 10 байт и файл к которому
  подключен канал содержит 10 байт, то прочесть признак конца канала невозможно. при попытке
  чтения будет возвращена ошибка превышения квоты
  
  синхронизированные каналы (задаются системным манифестом)
  каналы считаются синхронизированными если один канал читает данные которые пишет 
  другой канал. операция чтения в читающем канале блокируется до тех пор пока связанный 
  записывающий канал не поместит запрошенное количество байт. синхронизированные каналы 
  могут быть только последовательными. на этапе выполнения программы невозможно знать
  является ли канал синхронизированным.
  примечание: zerovm не гарантирует корректную работу в случае если синхронизированные 
  каналы управляются одним узлом.
  примечание: zerovm не гарантирует корректную работу в случае если произведена попытка
  синхронизировать более двух каналов.

  рекомендации
  - при работе с каналами лучше буферизовать вводвывод. это ускоряет работу программы. 
  - желательно выравнивать буфер на границу 0x10000

работа с памятью
----------------
  пользователю доступны 3 поля MANIFEST: stack_size, heap_ptr и heap_size, 
  которые определяют размер стека, а также местоположение и размер кучи. 
  пользователь может распоряжаться этими областями памяти по своему усмотрению

командная строка
----------------
  командная строка доступна через специальный канал "devnvram"
  argc и argv еще поддерживаются, но это может быть отменено в любой момент

переменные окружения
--------------------
  переменные окружения доступны через специальный канал "devnvram"
  envp еще поддерживаются, но это может быть отменено в любой момент

trap, trampoline и все остальное, что надо знать и не надо использовать.
------------------------------------------------------------------------
  trampoline - системная область содержащая таблицу nacl syscalls. размер одного
      элемента - 0x20 байт. область недоступна для записи. более подробная
      информация доступна в документах google nacl
  trap - syscall с номером 0. используется для вызова функций (см. enum TrapCalls)
      рекомендуется использовать обертки (см. "функции") вместо прямого вызова trap

использованные соглашения  термины
-----------------------------------
системный манифест - манифест управляющий поведением zerovm
пользовательский манифест - информация из системного манифеста доступная пользователю
    (см. struct UserManifest)
    
примеры использования api
-------------------------
примеры доступны из репозитория zerovm и находятся в папке testsfunctionaldemo 

</body>
</document>
 
docchannels.txt
<document>
<id>1005</id> 
<group>1005</group> 
<timestamp>71</timestamp>
<title>doc/channels.txt</title>
<body>
 
ZeroVM channels description
---------------------------

Channel = [host file name], [guest device name], [access type], [limit for reads], [limit for read bytes], [limit for writes], [limit for write bytes]
ex.: Channel = tmpfile.tmp, devstderr, 0, 0, 0, 1048576, 1048576

Channel = [host device name], [guest device name], [access type], [limit for reads], [limit for read bytes], [limit for writes], [limit for write bytes]
ex.: Channel = devstdin, devstdin, 0, 1073741824, 1073741824, 0, 0

Channel = [host socket], [guest device name], [access type], [limit for reads], [limit for read bytes], [limit for writes], [limit for write bytes]
ex.: Channel = tcp:127.0.0.1:55431, devinsome_host, 0, 1073741824, 1073741824, 0, 0

Channel = [host identifier], [guest device name], [access type], [limit for reads], [limit for read bytes], [limit for writes], [limit for write bytes]
ex.: Channel = tcp:21:, devoutnode21, 0, 0, 0, 1073741824, 1073741824

Channels are the key component of ZeroVM IO subsystem
On the host system side the channels are backed by the file system using either regular files or tcp sockets.
On the guest side the channel is a device file. It could be used as either character 
or block device it depends on the usage pattern and access type (see access types below).
All guest devices must reside in the dev directory or its subdirectories.

Channel fields passed via the manifest to ZeroVM (comma delimited, see examples above):
name -- can be a local file or device name or tcp socket or host identifier (see more on host identifiers below)
alias -- device name for the user side. Must follow the device naming scheme: devdevice-name
type -- access type. Can be in 0..3 range
gets -- limit for reads allowed from this channel
get_size -- limit on total amount of data to be read from this channel in bytes
puts -- limit for writes allowed for this channel
put_size -- limit on total amount of data to be written to this channel in bytes

Fields available for the untrusted code (see api.txt):
limits -- 4 limits for the channel
size -- channel size. only available for random access channels
type -- access type
name -- the channel name (the alias from the manifest)
the indices in the channels array can be used as "handles". also it is guaranteed 
that handles 0..2 represent stdin, stdout and stderr

Channel access types: 
0 - sequential read  sequential write (can be used as character device)
1 - random read  sequential write
2 - sequential read  random write
3 - random read  random write

For now ZeroVM supports 6 kinds of channels (defined by combination of access type and 4 readwrite limits):
- sequential read only channel (access type 0, both write limits are 0)
- random read only channel (access type 3, both write limits are 0)
- sequential write only channel (access type 0, both read limits are 0)
- random write only channel (access type 3, both read limits are 0)
- appendable channel. random read, sequential write. if the channel is not empty
  the write position is set next to the last byte (access type 1, any limits)
- full random access channel. can be read or written from any valid position (access type 3, any limits)

There are 3 mandatory channels (standard c90 streams): stdin, stdout, stdout.
The channels have well known device names "devstdin", "devstdout" and "devstderr".
You must have all 3 mandatory channels present in your manifest.
devstdin is a sequential read only channel
ex: Channel = path, devstdin, 0, reads, bytes, 0, 0
devstdout and devstderr are sequential write only channels
ex: Channel = path, devstdout, 0, 0, 0, writes, bytes

Channel is a file abstraction over the local files and network streams. Local files
can have random access type, network streams are always sequential.

All channels are opened before the session start and closed after session end. In case of
the channels io error ZeroVM will not start. ZeroVM preallocates specified byte size
for the local writable channels (this can be changed with -P switch, see zerovm_switches.txt).

Network (socket based) channels
-------------------------------

All socket based channels are either sequential read only or sequential write only.
They represent unidirectional connection between two ZeroVM instances.
You can have as many network channels as you want, although it's not advisable to have more 
than one channel in the same direction between the same two ZeroVM instances.
All network channels use TCP sockets. Write only channel will listen on socket while 
the read only channel will connect to the same socket from another instance.
All the read operations on the guest side will block until some data is available.
If you read a specific amount of data (using pread() for example) the read will block 
until this amount of data is available.
There is no support for unblocking reads for ZeroVM channels, it's by design.

Example of bidirectional connection between two ZeroVM instances:
Instance #1, IP addr 10.0.0.1

Channel = tcp:10.0.0.1:34423, devoutinstance2, 0, 0, 0, 9999999, 9999999
Channel = tcp:10.0.0.2:56645, devininstance2, 0, 9999999, 9999999, 0, 0

Instance #2, IP addr 10.0.0.2

Channel = tcp:10.0.0.1:34423, devininstance1, 0, 9999999, 9999999, 0, 0
Channel = tcp:10.0.0.2:56645, devoutinstance1, 0, 0, 0, 9999999, 9999999

Each read from read only network channel can result in zvm_eof indicator read.
This means that the other party closed the channel, you will get the same zvm_eof 
each time you try to read from this channel again.
If integrity checks are in place (zerovm was run with -e option) 
zvm_eof will contain channel integrity checksum.

Host identifiers
----------------

In the case of clustered runs there is no way to know the network topology before actually trying to run ZeroVM instances.
Host IPs and ports are not known until the very start of ZeroVM executable.
To solve this problem we introduce the host identifiers.
Each ZeroVM instance (guest) in clustered configuration gets identifier (just a running number)
The identifier is unique only within the current cluster configuration.
For example if we want to run map-reduce job with 4 mappers and 5 reducers, there will be 9 identifiers (1..9)
and one number will be assigned for each instance (be it mapper or reducer).

To resolve the host identifiers you will need the following data in manifest:

NameServer = udp:[ip address]:[port]
NodeName = [instance name], [host identifier]

Name server line contains the ip address and port of udp name server that will resolve host ids.
Node name line contains the name of this node (just a string) and the host identifier of this node

Example:

NameServer = udp:10.0.0.254:5544
NodeName = mapper-21, 34

The two instance example (see above) will look like this:
Instance #1

Channel = tcp:2:, devoutinstance-2, 0, 0, 0, 9999999, 9999999
Channel = tcp:2:, devininstance-2, 0, 9999999, 9999999, 0, 0
NameServer = udp:10.0.0.254:5544
NodeName = instance-1, 1

Instance #2

Channel = tcp:1:, devininstance-1, 0, 9999999, 9999999, 0, 0
Channel = tcp:1:, devoutinstance-1, 0, 0, 0, 9999999, 9999999
NameServer = udp:10.0.0.254:5544
NodeName = instance-2, 2

If the manifest contains host identifiers ZeroVM will do the following on startup:

1) for all write only channels, bind on any available port (but 1st will try 49152..65535) for each one
2) send discovery packet to name server with all the bound ports
discovery packet also contains all identifiers for read only channels present in the manifest
3) wait for name server reply
4) name server replies with mapping of identifiers sent in 2) to ip:port tuples
5) connect to all read only channels

After this 5 step operation all channels will be set up with correct unidirectional data paths
The reference implementation of name server daemon can be found in ZRT library (name_server.py).
You can also use ZRT networked samples to see the flow, namely 'reqrep' or 'disort' sample.

To find more info about name server consult name_server.txt

Limitations
-----------

- The number of channels in the manifest is limited to 6548 "Channel" lines
- user program cannot bind and connect network channel to itself

</body>
</document>
 
docdeterminism.txt
<document>
<id>1006</id> 
<group>1006</group> 
<timestamp>75</timestamp>
<title>doc/determinism.txt</title>
<body>
 
документ описывает меры принимаемые zerovm для обеспечения детерминизма
(это предварительная версия документа)

о каком детерминизме речь?
zerovm гарантирует, что одинаковые исполняемые модули (nexe) запущенные с одинаковыми настройками 
на одинаковых данных сгенерируют одинаковые результаты. более того одинаковыми будут и снимки
памяти. в дальнейшем, может использоваться термин "принцип определенности".

для обеспечения детерминизма используются следующие средства:
1. zerovm toolchain. обеспечивает построение исполняемых модулей - исполняемых, 
   легко валидируемых файлов
2. ncval: nacl validator. программа для проверки исполняемых модулей.
   примечание: кроме валидатора из nacl, zerovm toolchain предлагает другой валидатор,
   почти такой же но запрещающий использование rdtsc
3. каналы - файловая абстракция над данными (см. channels.txt)
4. trap функции безопасные для детерминизма
5. проверка платформы на которой запущен zerovm (должен поддерживаться dep - data execution prevention)
6. резервирование пользовательских ресурсов до запуска пользовательского кода и
   и их освобождение только после завершения работы пользовательского кода
7. перехват сигналов и аварийное завершение zerovm в случае возникновения ошибки.
   в этом случае результаты работы пользовательской программы должны быть отброшены
8. вычисление sha1 хэш-значения памяти и каналов после завершения nexe (etag). для 
   одинаковых заданий (одинаковые nexe запущенные на одних данных с одними настройками)
   это значение будет одинаковым. и наоборот, совпадение etag-ов, с большой вероятностью
   (в пределах возможностей sha1) означает совпадение заданий.

проблемы связанные с детерминизмом:
- не до конца исследован набор доступных nacl инструкций. возможно среди них есть "опасные" для 
  "принципа определенности"
- возможные утечки из "доверенного кода", связанные с вероятным несовершенством защиты zerovm
  для предотвращения утечек используется "последняя линия обороны" - код выполняющийся
  непосредствено перед началом работы nexe и ограничивающий использование ресурсов, а так же
  "чистка" регистров перед каждой передачей управления в "опекаемый" код

</body>
</document>
 
docenviroment.txt
<document>
<id>1007</id> 
<group>1007</group> 
<timestamp>79</timestamp>
<title>doc/enviroment.txt</title>
<body>
 
this document describes user environment (custom attributes)
============================================================
(deprecated. user environment will be available via "devnvram" and will not as main() argument) 
 
This design replaces the old one: "ContentType", "TimeStamp", "XObjectMetaTag", "UserETag" -
these keywords were removed from ZeroVM manifest.
 
The new design provides a new manifest keyword: "Environment". The keyword uses a new format:
keyword = value1, value2, value3, value4,.. 

For example:
Environment = TimeStamp, 1337012520, UserETag, 74ebada55, XObjectMetaTag, klaatu_barada_nikto

Will be translated to user environment pairs:
TimeStamp=1337012520
UserETag=74ebada55
XObjectMetaTag=klaatu_barada_nikto

User program can access environment via main() arguments:
int main(int argc, char **argv, char **envp)
where "envp" is the array of asciiz strings. It is guaranteed that the last string 
is NULL (just like "argv"). Also the user program can use ZeroVM API to read 
an environment (see "api.txt").

Some environment arguments are meant to be used by ZRT (andor other libraries). 
For instance "TimeStamp". ZeroVM, however doesn't control it.
</body>
</document>
 
docnexe_debug.txt
<document>
<id>1008</id> 
<group>1008</group> 
<timestamp>83</timestamp>
<title>doc/nexe_debug.txt</title>
<body>
 
there is debugging script calling gdb from zerovm toolchain

------------------------------------------------------------
#!binsh
filename=$(basename "$1")
name="${filename%.*}"

# help screen
if [ -z $1 ]; then
  echo usage: zgdb \zvm module\
  echo example:
  echo   zgfb hello.nexe
  echo note: manifest should exist with the same name and \"manifest\" extesion
  exit
fi

# check if nexe exist
if [ ! -f $1 ]; then
  echo $1 does not exist
  exit
fi

# check if manifest exist
if [ ! -f $name.manifest ]; then
 echo $name.manifest does not exist
  exit
fi

#create debug script
echo set confirm off  debug.scp
echo b NaClCreateMainThread  debug.scp
echo r  debug.scp
echo b main  debug.scp
echo add-symbol-file $name.nexe 0x440a00020000  debug.scp
echo shell clear  debug.scp
echo c  debug.scp
echo d br  debug.scp

# run debug session
gdb --command=debug.scp --args $ZEROVM_ROOTzerovm -sQe3 $name.manifest

rm debug.scp
------------------------------------------------------------

the newest version of script above can be found in zerovm repository in
testsfunctionaldemodebugzgdb

notes:
- module should exist and have debug information
- appropriate manifest should be available
- it is possible to viewedit variables from the heap but names cannot be used directly.
  temporary solution is to use absolute address + 0x440a00000000
</body>
</document>
 
docpremature_manual.txt
<document>
<id>1009</id> 
<group>1009</group> 
<timestamp>87</timestamp>
<title>doc/premature_manual.txt</title>
<body>
 
this document is under construction.
полное описание zerovm

оглавление:
- dictionary, bestiary
- установка zerovm, nacl sdk e.t.c.
- начало работы (quick start)
- командная строка
- отчеты
- лог
- код возврата
- обработка сигналов
- детерминизм
- область системных данных пользователя


dictionary, bestiary (###):
(нижеследующие термины возможно не совсем соответствуют общепринятым и не совсем точно
описывают то о чем рассказывается в документе. некоторые термины даны на английском языке,
а некоторые - на русском. возможно что-то я пропустил по невнимательности. прошу прощения. 
желающие могут предложить свои варианты, более разумные, ясные и аргументированные)
- zerovm
  это минимальная виртуальная машина для запуска nacl nexe modules
  zerovm не поддерживает большую часть nacl syscalls, вместо этого он использует механизм 
  передачи управления в изолируемый код (syscallback) и позволяет ему сделать всю работу.
  при этом untrusted код может использовать zerovm api для получения обслуживания 
  вводавывода, выделения памяти, завершения работы и т.д.
- детерминизм, сильный детерминизм, слабый детерминизм
  (можно взять из determinism.txt)
- zerovm api
  (можно взять из api.txt)
- zrt
  библиотека "времени выполнения" обслуживает nacl syscalls вместо zerovm
  в последнее время смысл zrt немного изменился и включает в себя так же
  nacl модули портированного под zerovm программного обеспечения. рассматривается
  возможность выделения этого "довеска" в самостоятельные проекты.
  если специально не оговаривается, то zrt надо рассматривать как прослойку между
  nacl glibc и zerovm. zrt позволяет компилировать cc++ программы для zerovm
  без их переделки (достаточно включить "zrt.h" в файл main()) 
- swift
  "облачное хранилище". часть проекта openstack. проектом litestack используется как
  основная часть файловой системы хранилища
- name server
  вспомогательная программа обеспечивающая установление связи между zerovm-ами
- nacl sdk
  инструмены позволяющие разрабатывать программы для google native client (nacl)
  подробная информация может быть получена на https:developers.google.comnative-clientsdk
- nacl syscall
  системный вызов nacl
- syscallback
  (большую часть текста можно взять из "syscallback.txt")
- trap
  механизм призваный заменить nacl syscalls. занимает 0-е положение в таблице
  системных вызовов (trampoline)
- rdtsc issue
  инструкция rdtsc - часть системы команд i86, возвращает информацию счетчика tsc
  и таким образом позволяет пользовательской программе замерять время выполнения
  собственного кода, что нарушает детерминизм. найдено временное решение: сделана
  заплатка в валидаторе nacl, инструкция объявлена недопустимой, сделана заплатка
  в nacl_stubout и инструкция заменяется nop (no operation)
- квантовые источники
  источник квантовых данных. допустим в "слабой модели" детерминизма. не допускает
  "воспроизведения", другими словами невозможно воссоздать условия при которых источник
  будет выдавать те же данные, что и в предыдущую сессию. например, devurandom 
- квантовые данные
  невоспроизводимые данные из квантового источника
- каналы
  (описание пользовательских каналов. и описание их реализации на стороне zerovm.
  ошибки каналов, типы и т.д. большую часть можно взять из документа "channels.txt")
- запутанный канал
  каналы по которым передаются одни и те же данные из разных источников объединены в
  один условный канал, который может контролировать правильность передаваемых данных
  (при количестве каналов более 1) и восстанавливать данные (при количестве каналов 
  более 2). упрощенно алгоритм действия запутанного канала можно описать следующим 
  образом:
  1. при поступлении очередной порции данных от всех каналов составляющих запутанный
     канал, данные сравниваются между собой (ниже будет описан случай данных разного 
     размера) если есть хотя бы 2 канала с одинаковыми данными, данные считаются верными
     и используются, а каналы передавшие неверные данные отключаются. т.о. можно 
     запускать кластер на потенциально сбойном оборудовании
  2. для ускорения работы кластера можно не дожидаться данных из остальных источников 
     запутанного канала, если уже есть 2 канала приславшие совпадающие данные
  
  пока что предполагается, что размер пакета данных в запутанном канале всегда одинаков
  для всех составляющих его каналов. однако, можно легко убрать это ограничение если
  отсылать "отвалидированные" данные в том количестве в котором они уже есть
  
- пользовательская сессия
  все действия выполненные пользовательской программой от начала ее работы до конца. 
- модуль nacl (nexe, пользовательский код)
  модуль построенный в соответствиями с требованиями nacl и запускаемый или под управлением
  sel_ldr из nacl, или zerovm 
- доверенный код
  код проекта не предназначенный для выполнения под управлением zerovm
- опекаемый код (изолируемый код, untrusted side)
  код исполняемый под управлением zerovm 
- трамплин (батут, таблица прерываний)
  опекаемый код. занимает 64kb, начиная с адреса 0x10000 в пространстве пользователя.
  содержит адреса всех системных вызовов nacl и trap 
- пользовательское пространство (пользовательская адресация)
  32-битное пространство являющееся частью 64-битного пространства zerovm. занимает 4gb
  (не все пользовательское пространство доступно пользователю). содержит трамплин,
  пользовательский код и данные, пользовательскую кучу и стек. также к пользовательскому 
  пространству можно отнести 2 бампера предотвращающих выход за пределы 
  пользовательского пространства. бамперы недоступны пользователю и занимают 40gb + 64kb и 40gb
- пользовательская куча
  доступная на чтение и запись область из пространства пользователя, расположенная до стека.
  размер кучи определяется манифестом сессии
- пользовательский стек
  стек расположенный в пространстве пользователя (в самом конце пространства). занимает 16gb
- манифест (системный манифест)
  (часть текста можно взять из "manifest.txt")
- манифест (пользовательский манифест)
  (часть текста можно взять из "api.txt")
- кластер
  один или больше zerovm-ов работающих одновременно и связанных каналами
  при этом совокупность этих каналов представляют собой связный направленный граф
- однородные аппаратные средства
  компьютеры имеющие процессоры с одинаковой системой команд одинаково работающих
  на одинаковых данных. (если процессоры, например, возращают разные значения при
  вызове cpuid, то они не считаются одинаковыми). однако если программа не 
  использует различающиеся возможности процессоров, то компьютеры поддерживающие
  только требуемое программой подмножество инструкций, можно считать условно
  однородными.
- пользовательское окружение
  переменные окружения доступные пользователю через trap или через соответствующий
  параметр main(int argc, char **argv, char **envp) - envp. пользовательское окружение
  задается манифестом
- пользовательская командная строка
  задается манифестом. доступна через параметры main()
- имя узла
  argv[0] (см. "пользовательская командная строка"). задается манифестом.
- etag
  механизм контроля целостности данных. используется для данных передаваемых по каналам,
  пользовательской памяти. сейчас в качестве функции подсчета контрольных сумм
  применяется sha1. каждый канал связи завершается спецсимволом zvm_eof, 
  включающим в себя контрольную сумму (control tag, tag), что позволяет
  обнаруживать порчу данных при передаче


установка zerovm, nacl sdk e.t.c.
(пока что эта часть не готова, часть информации можно получить из README,
остальное будет добавлено позднее при участии группы litestack ops)

для работы zerovm требует наличия в пути следующих программ: ncval, ncval_stubout
предполагается, что обе программы взяты из проекта zerovm из папки libbin, где
находятся расширенные версии приспособленные для нужд гипервизора. можно использовать 
аналогичные программы из проекта google nacl, но в этом случае не гарантируется
детерминизм.

  ncval - валидатор для nacl nexe. нужен для проверки соответствия скомпилированного 
  пользователем кода требованиям безопасности nacl. как расширение, валидатор
  проверяет код и на нарушение детерминизма

  ncval_stubout - утилита для замены инструкций нарушающих требования nacl на 
  безопасные. запрещенные инструкции транслируются в hlt (останов). как расширение,
  инструкции нарушающие детерминизм заменяются nop (no operation).


начало работы (quick start)
(в этой главе описывается создание приложения для выполнения под управлением zerovm)


командная строка zerovm
(описание ключей запуска zerovm и примеры использования) 


отчеты:
пользовательская сессия может завершиться нормально или аварийно, в любом случае
zerovm возвращает отчет. единственный случай когда отчет не возвращается - zerovm
не успел стартовать nexe, ошибка произошла на этапе инициализации самого гипервизора.

пример отчета:
validator state = 0
user return code = 0
etag = fb28895f24c219518f87fbb53e1366192f92b91b
accounting = 0.01 0.00 536870912 0 0 0 2 35 0 0 0 0
exit state = ok

1. статус валидатора: 
   0 - пользовательский модуль прошел валидацию
   1 - ошибка валидации
   2 - другая ошибка
2. код возврата пользовательского модуля
3. контрольная сумма пользовательской памяти и пользовательских данных
4. учет ресурсов потраченных за сессию
   - системное время (время потраченное на вводвывод)
   - пользовательское время
   - выделенная пользователю память (в байтах)
   - пользовательский своп (не используется)
   - количество локальных чтений
   - количество локально прочитанных байт
   - количество локальных записей
   - количество локально записанных байт
   - количество удаленных чтений
   - количество удаленно прочитанных байт
   - количество удаленных записей
   - количество удаленно записанных байт
5. статус сессии. строка отличная от "ok" описывает ошибку которой
   завершилась сессия, и место ее возникновения (trusteduntrusted)

   примечание: триггеры на сигналы 24 и 25 устанавливаются самим
   zerovm и контролируют использование времени и дискового пространства.
   т.о. появление этих сигналов в доверенном коде - штатная ситуация


лог:
  всю техническую информацию о текущей сессии zerovm помещает в syslog
  (varlogsyslog). при использовании расширенного логгирования и не 
  настроенном сислоге часть сообщений может пропасть. расширенное логгирование
  должно использоваться с осторожностью, оно может повлиять на скорость
  исполнения пользовательского кода. не рекомендуется использовать лог zerovm
  для отладки пользовательских программ.

  примечание: все временнЫе интервалы указаны в "абсолютном" времени. т.е.
  если процесс ждал час, а реально работал только секунду, в логе будет отражен
  весь час (в отчете, конечно, будет видна только секунда) 


код возврата:
  при завершении сессии гипервизор возращает код. ненулевой код означает
  ошибку. все коды ошибок соответствуют значениям errno.h
  

обработка сигналов:
  при получении сигнала zerovm уже не возращает управление пользовательскому
  модулю, закрывает каналы, подсчитывает контрольную сумму сессии,
  использованные ресурсы и выводит отчет, после чего завершается.


детерминизм:
(todo: сократить и переместить в бестиарий)
  zerovm реализует "слабую модель детерминизма", которая в отличие от "сильной" 
  позволяет использовать через обычные каналы квантовые источники данных (будет 
  описано позднее) и не работает на неоднородном аппаратном обеспечении. есть и 
  еще несколько ограничений, но не принципиальных, а технических, связаных с 
  использованием сторонних библиотек. после решения всех проблем планируется
  реализация "сильной модели детерминизма" (вообще, введение двух "детерминизмов"
  с громоздким описанием их отличий, вместо простого и ясного детерминизма,
  возникло из-за разногласий в команде о том, что считать детерминизмом)

  условия детерминизма (слабого):
  - пользовательская сессия (nexe run time) должна завершиться успешно
    (имеется ввиду отсутствие прерывания исполнения в результате возникновения
    сигнала в доверенном или опекаемом коде)
  - сессия должна выполняться на однородном "железе"
    (все компьютеры должны иметь одинаковые процессоры. под "одинаковыми" имеются
    ввиду процессоры одинаково обрабатывающие одинаковые данные. например, два
    процессора интел выдающие разную информацию по cpuid не будут считаться одинаковыми)
  - не должны использоваться "квантовые источники" данных
    (например, подключение devurandom к пользовательской программе сломает детерминизм.
    правильным рещением будет использование специальной сессии zerovm, которая запишет
    необходимое количество данных из devurandom в файл, а затем другая сессия 
    воспользуется уже сохраненными данными. вообще, "квантовые" данные легко превратить
    в обычные "фиксацией" и это можно делать параллельно с их обработкой)
  - должен использоваться механизм контроля данных - etag. в случае обнаружения ошибки в
    канале вся сессия должна быть рестартована. так же должны быть рестартованы и все
    зависимые сессии. в дальнейшем, для этого будут использоваться "запутанные" каналы,
    которые смогут не только обнаруживать порчу данных, но и "исправлять"  их (на самом
    деле, не столько исправлять сколько переключаться на источник выдающий верные данные).

    примечание: для того чтобы устранить "квантовые" источники и перейти к "сильной"
    модели детерминизма достаточно перед пользовательской сессией запустить специальную -
    превращающую квантовые данные в детерминированные. простая запись на локальном диске
    решает эту проблему. например, значения прочитанные из devurandom могут быть сохранены
    в файл, а последующая и все остальные сессии будут читать уже сохраненные данные.
    эта логика может быть даже интегрирована в zerovm, однако поскольку количество данных
    для прочтения известно только пользовательской программе, гипервизору придется
    использовать ограничения канала, указанные в манифесте. таким образом, "квантовые"
    данные не могут быть учтены аккаунтингом точно. мало того, zerovm будет вынужден
    использовать дополнительное дисковое пространство для хранения "расквантованных"
    данных. кроме того, возможной проблемой является то, что время ожидания вводавывода
    не учитывается аккаунтингом. стоит учесть, что предлагаемое решение исключает
    вынесение логики за пределы пользовательской сессии, иначе говоря, пользователь
    не может превратить свою сессию в недетерминированную. все решения либо вычисляются
    из предопределенных данных воспроизводимым способом, либо принимаются до начала работы
    сессии.
    
область системных данных пользователя:
(предварительное описание. текущую реализацию можно посмотреть в apizvm.h)
  по адресу 0xFEFFFFFC (4 байта перед стеком) находится указатель на struct UserManifest
  которая содержит следующие поля в указанном порядке:
  (*) -- адрес структуры можно передавать через стек. это более универсальный подход.
         изменение размеров и местоположения стека не будет требовать перекомпиляции
         пользовательских программ. однако, при этом не контролируется stack underflow
         в случае если производится чтение из стека.
  
  struct UserManifest
  1. указатель на кучу: (void*) 4bytes
  2. размер кучи: (uint32_t) 4bytes
  3. размер стека: (uint32_t) 4bytes
  4. количество каналов: (uint32_t) 4bytes
  5. указатель на массив структур каналов: (struct ZVMChannel*) (4)*48bytes
  6. указатель на окружение: устарело
  
  struct ZVMChannel
  1. массив ограничений вводавывода канала: (int64_t) IOLimitsCount*8bytes;
  2. размер канала: (int64_t) 8bytes
  3. тип канала: (int32_t) 4bytes
  4. указатель на имя канала: (char*) 4bytes
  
  IOLimitsCount == 4
  GetsLimit: разрешенное количество чтений
  GetSizeLimit: разрешенное для чтения количество байт
  PutsLimit: разрешенное количество записей
  PutSizeLimit: разрешенное для записей количество байт
  
</body>
</document>
 
doctrap.txt
<document>
<id>1010</id> 
<group>1010</group> 
<timestamp>91</timestamp>
<title>doc/trap.txt</title>
<body>
 
This document describes the trap() call
------------------------------

Trap is a syscall number 0 from trampoline and the only available syscall 
(nacl syscalls not supported anymore). This syscall accepts 1 argument:
uint64_t* and returns an int32_t value.

Trap argument (can be treated as array of uint32_t) has the following structure:
arg[0] == function number (element of TrapCalls enum from "zvm.h")
arg[1] == reserved (not used)
arg[2] .. arg[N] = arguments to this function

trap() supports the following functions:
  TrapRead
  TrapWrite
  TrapExit
  
detailed information regarding trap functions can be found in "api.txt"

</body>
</document>
 
doctroubleshouting.txt
<document>
<id>1011</id> 
<group>1011</group> 
<timestamp>95</timestamp>
<title>doc/troubleshouting.txt</title>
<body>
 
This document describes possible zerovm problems
(the document should be updated or removed)
-------------------------------------------------


zerovm troubleshouting
--------------------------
1. On ubuntu 11.10 desktop 64-bit invoking make produces error:
usrbinld: cannot find -lcrypto
collect2: ld returned 1 exit status
make: *** [zerovm] Error 1
solution: not found

zerovm api troubleshouting
--------------------------
1.
"error while loading shared libraries: libz.so.1:" when compiling "apizvm.c"
solution: sudo apt-get install ia32-libs


</body>
</document>
 
doczvm_security.txt
<document>
<id>1012</id> 
<group>1012</group> 
<timestamp>99</timestamp>
<title>doc/zvm_security.txt</title>
<body>
 
This document describes ZeroVM security, how ZeroVM stands against possible attacks
-----------------------------------------------------------------------------------

We assume that original NaCl implementation is perfect and will analyze only the 
ZeroVM features that can affect the system security.

trap()
------
The trap() syscall contains several functions each of them can have bugs that lead to security
vulnerability. Therefore each trap() function must have full test coverage. Tests can be
found in repository folder testsfunctional

Other zerovm code
-----------------
Most dangerous are the functions that work when user application is running. These are: syscalls,
nacl_syscall_64.S, nacl_switch_64.S nacl_syscall_hook.c and some other code. All this code should
be covered with security tests. Some tests can be found in repository folder testssecurity 

Loader
--------
ZeroVM has some changes in user module loading process:
1. a new memory region added: user manifest. this is a read only memory area placed right 
   before the user stack. user manifest contains information about channels, heap and stack
2. all trampoline syscalls are disabled (except trap) and populated by the uniform pattern
   calling always constant memory address 0x5afeca110000
3. command line arguments, environment and modulle name is not available from the user stack
   (actually it is avaiilable, but will be removed as soon as "devnvram" will be added)
   it is more safe to allow user module to parse all its command data on untrusted side.
   appropriate support will be added to zerovm toolchain

Network channels
----------------
to send user data from one session to other, zerovm uses zeromq library v2.2.x. 

Manifest
--------
Current version of the manifest is treated as secure. User can only viewchange specific fields. However
security tests will be useful.

</body>
</document>
 
