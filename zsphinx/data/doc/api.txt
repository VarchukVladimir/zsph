ATTENTION (please help!):
this document should be traslated to english as soon as possible

этот документ описывает пользовательский api zerovm

макроопределения, перечисления
------------------------------
enum AccessType - тип доступа. атрибут используется в описании каналов (см. "каналы") 
  SGetSPut - последовательное чтение и последовательная запись
  RGetSPut - произвольное чтение и последовательная запись
  SGetRPut - последовательное чтение и произвольная запись
  RGetRPut - произвольный доступ на чтение и запись.

enum IOLimits - ограничения доступа. атрибут используется в описании каналов (см. "каналы")
  GetsLimit - разрешенное количество чтений
  GetSizeLimit - количество байт которое может быть прочитано
  PutsLimit - разрешенное количество записей
  PutSizeLimit - количество байт которое может быть записано

enum TrapCalls - функции trap (см. "функции")
  TrapRead - чтение из канала
  TrapWrite - запись в канал
  TrapExit - завершение пользовательской программы

типы данных zerovm api
-----------------------
struct ZVMChannel - описание канала (см. "каналы")
  limits - ограничения канала (см. enum IOLimits)
  size - размер канала. не установлено для каналов последовательного доступа
  type - тип доступа (см. "enum AccessType")
  name - имя канала

вызовы nacl (nacl syscalls)
---------------------------
  не поддерживаются 

функции zerovm api
------------------
  в zerovm существует единственный системный вызов - trap, соответствующий нулевому адресу 
  в таблице trampoline . trap обслуживает 3 функцим (см. enum TrapCalls). для доступа 
  к этому сервису рекомендуется использовать "обертки" определенные в api/zvm.h:
  
  zvm_pread(desc, buffer, size, offset)
  читает из канала с номером "desc" в область памяти "buffer" "size" байт. если канал 
  имеет произвольный доступ на чтение, "offset" указывает позицию в канале с которой 
  производится чтение. для канала последовательного доступа значение offset игнорируется.
  возвращает количество прочитанных байт, 0 - в случае конца канала или -errno при 
  возникновении ошибки (errno коды могут быть получены man errno).

  zvm_pwrite(desc, buffer, size, offset)
  пишет в канал с номером "desc" из области памяти "buffer" "size" байт. если канал 
  имеет произвольный доступ на запись "offset" указывает позицию в канале в которую 
  производится запись. для канала последовательного доступа значение offset игнорируется.
  возвращает количество записанных байт, или -errno при возникновении ошибки 
  (errno коды могут быть получены man errno).

  zvm_exit(code)
  завершает программу с указанным кодом

переменные
----------
struct UserManifest
  heap_ptr - начало доступной памяти (кучи) пользовательской программы
  heap_size - размер кучи в байтах
  stack_size - размер стека в байтах 
  channels_count - количество доступных каналов (3 канала: 0..2 доступны всегда)
  channels - массив структур доступных каналов (см. "struct ZVMChannel")
  
  пользовательской программе доступно макроопределение MANIFEST указывающее 
  на область содержащую вышеперечисленную информацию и доступную только для
  чтения.

каналы
------
  каналы реализуют файловую абстракцию над доступными zerovm средствами ввода/вывода. в данный
  момент это локальные файлы и сетевые соединения. количество доступных каналов неизменно для
  сеанса работы и известно сразу после инициалиции zerovm api (см. "zvm_init"). более подробную
  информацию об атрибутах каналов можно получить из "struct ZVMChannel". для обслуживания каналов
  предназначена часть функций trap (см. "функции"). гарантируется наличие 3х стандартных каналов:
  stdin, stdout, stderr.

  специальные каналы:
  stdin - стандартный ввод. канал последовательного доступа. только чтение.
          доступен по индексу 0 в MANIFES->channels
  stdout - стандартный вывод. канал последовательного доступа. только запись.
          доступен по индексу 1 в MANIFES->channels
  stderr - стандартный вывод ошибок. канал последовательного доступа. только запись.
          доступен по индексу 2 в MANIFES->channels
          
  реализована поддержка каналов следующих типов:
  - только для чтения последовательного доступа
  - только для чтения произвольного доступа
  - только для записи последовательного доступа
  - только для записи произвольного доступа
  - appendable (cdr). канал имеющий произвольный доступ на чтение и последовательный доступ
    при записи. кроме того если канал имеет ненулевую длину, начальная позиция записи
    указывает на байт следующий за последним
  - канал произвольного доступа для чтения и записи
    
  длина каналов и признак конца канала:
  для каналов произвольного доступа определена длина канала (количество байт канала), 
  описывается полем "size" (см. struct ZVMChannel). для каналов последовательного доступа
  поле "size" не определено, однако для каналов "для чтения" при достижении конца канала
  функцией zvm_pread возвращается 0
  примечание: 
  признак конца канала является специальным символом и учитывается limits. т.о.
  если через канал последовательного доступа разрешено прочесть 10 байт и файл к которому
  подключен канал содержит 10 байт, то прочесть признак конца канала невозможно. при попытке
  чтения будет возвращена ошибка превышения квоты
  
  синхронизированные каналы (задаются системным манифестом)
  каналы считаются синхронизированными если один канал читает данные которые пишет 
  другой канал. операция чтения в читающем канале блокируется до тех пор пока связанный 
  записывающий канал не поместит запрошенное количество байт. синхронизированные каналы 
  могут быть только последовательными. на этапе выполнения программы невозможно знать
  является ли канал синхронизированным.
  примечание: zerovm не гарантирует корректную работу в случае если синхронизированные 
  каналы управляются одним узлом.
  примечание: zerovm не гарантирует корректную работу в случае если произведена попытка
  синхронизировать более двух каналов.

  рекомендации
  - при работе с каналами лучше буферизовать ввод/вывод. это ускоряет работу программы. 
  - желательно выравнивать буфер на границу 0x10000

работа с памятью
----------------
  пользователю доступны 3 поля MANIFEST: stack_size, heap_ptr и heap_size, 
  которые определяют размер стека, а также местоположение и размер кучи. 
  пользователь может распоряжаться этими областями памяти по своему усмотрению

командная строка
----------------
  командная строка доступна через специальный канал "/dev/nvram"
  argc и argv еще поддерживаются, но это может быть отменено в любой момент

переменные окружения
--------------------
  переменные окружения доступны через специальный канал "/dev/nvram"
  envp еще поддерживаются, но это может быть отменено в любой момент

trap, trampoline и все остальное, что надо знать и не надо использовать.
------------------------------------------------------------------------
  trampoline - системная область содержащая таблицу nacl syscalls. размер одного
      элемента - 0x20 байт. область недоступна для записи. более подробная
      информация доступна в документах google nacl
  trap - syscall с номером 0. используется для вызова функций (см. enum TrapCalls)
      рекомендуется использовать обертки (см. "функции") вместо прямого вызова trap

использованные соглашения / термины
-----------------------------------
системный манифест - манифест управляющий поведением zerovm
пользовательский манифест - информация из системного манифеста доступная пользователю
    (см. struct UserManifest)
    
примеры использования api
-------------------------
примеры доступны из репозитория zerovm и находятся в папке tests/functional/demo 
