документ описывает меры принимаемые zerovm для обеспечения детерминизма
(это предварительная версия документа)

о каком детерминизме речь?
zerovm гарантирует, что одинаковые исполняемые модули (nexe) запущенные с одинаковыми настройками 
на одинаковых данных сгенерируют одинаковые результаты. более того одинаковыми будут и снимки
памяти. в дальнейшем, может использоваться термин "принцип определенности".

для обеспечения детерминизма используются следующие средства:
1. zerovm toolchain. обеспечивает построение исполняемых модулей - исполняемых, 
   легко валидируемых файлов
2. ncval: nacl validator. программа для проверки исполняемых модулей.
   примечание: кроме валидатора из nacl, zerovm toolchain предлагает другой валидатор,
   почти такой же но запрещающий использование rdtsc
3. каналы - файловая абстракция над данными (см. channels.txt)
4. trap функции безопасные для детерминизма
5. проверка платформы на которой запущен zerovm (должен поддерживаться dep - data execution prevention)
6. резервирование пользовательских ресурсов до запуска пользовательского кода и
   и их освобождение только после завершения работы пользовательского кода
7. перехват сигналов и аварийное завершение zerovm в случае возникновения ошибки.
   в этом случае результаты работы пользовательской программы должны быть отброшены
8. вычисление sha1 хэш-значения памяти и каналов после завершения nexe (etag). для 
   одинаковых заданий (одинаковые nexe запущенные на одних данных с одними настройками)
   это значение будет одинаковым. и наоборот, совпадение etag-ов, с большой вероятностью
   (в пределах возможностей sha1) означает совпадение заданий.

проблемы связанные с детерминизмом:
- не до конца исследован набор доступных nacl инструкций. возможно среди них есть "опасные" для 
  "принципа определенности"
- возможные утечки из "доверенного кода", связанные с вероятным несовершенством защиты zerovm
  для предотвращения утечек используется "последняя линия обороны" - код выполняющийся
  непосредствено перед началом работы nexe и ограничивающий использование ресурсов, а так же
  "чистка" регистров перед каждой передачей управления в "опекаемый" код
