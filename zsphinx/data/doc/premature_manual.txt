this document is under construction.
полное описание zerovm

оглавление:
- dictionary, bestiary
- установка zerovm, nacl sdk e.t.c.
- начало работы (quick start)
- командная строка
- отчеты
- лог
- код возврата
- обработка сигналов
- детерминизм
- область системных данных пользователя


dictionary, bestiary (###):
(нижеследующие термины возможно не совсем соответствуют общепринятым и не совсем точно
описывают то о чем рассказывается в документе. некоторые термины даны на английском языке,
а некоторые - на русском. возможно что-то я пропустил по невнимательности. прошу прощения. 
желающие могут предложить свои варианты, более разумные, ясные и аргументированные)
- zerovm
  это минимальная виртуальная машина для запуска nacl nexe modules
  zerovm не поддерживает большую часть nacl syscalls, вместо этого он использует механизм 
  передачи управления в изолируемый код (syscallback) и позволяет ему сделать всю работу.
  при этом untrusted код может использовать zerovm api для получения обслуживания 
  ввода/вывода, выделения памяти, завершения работы и т.д.
- детерминизм, сильный детерминизм, слабый детерминизм
  (можно взять из determinism.txt)
- zerovm api
  (можно взять из api.txt)
- zrt
  библиотека "времени выполнения" обслуживает nacl syscalls вместо zerovm
  в последнее время смысл zrt немного изменился и включает в себя так же
  nacl модули портированного под zerovm программного обеспечения. рассматривается
  возможность выделения этого "довеска" в самостоятельные проекты.
  если специально не оговаривается, то zrt надо рассматривать как прослойку между
  nacl glibc и zerovm. zrt позволяет компилировать c/c++ программы для zerovm
  без их переделки (достаточно включить "zrt.h" в файл main()) 
- swift
  "облачное хранилище". часть проекта openstack. проектом litestack используется как
  основная часть файловой системы хранилища
- name server
  вспомогательная программа обеспечивающая установление связи между zerovm-ами
- nacl sdk
  инструмены позволяющие разрабатывать программы для google native client (nacl)
  подробная информация может быть получена на https://developers.google.com/native-client/sdk/
- nacl syscall
  системный вызов nacl
- syscallback
  (большую часть текста можно взять из "syscallback.txt")
- trap
  механизм призваный заменить nacl syscalls. занимает 0-е положение в таблице
  системных вызовов (trampoline)
- rdtsc issue
  инструкция rdtsc - часть системы команд i86, возвращает информацию счетчика tsc
  и таким образом позволяет пользовательской программе замерять время выполнения
  собственного кода, что нарушает детерминизм. найдено временное решение: сделана
  заплатка в валидаторе nacl, инструкция объявлена недопустимой, сделана заплатка
  в nacl_stubout и инструкция заменяется nop (no operation)
- квантовые источники
  источник квантовых данных. допустим в "слабой модели" детерминизма. не допускает
  "воспроизведения", другими словами невозможно воссоздать условия при которых источник
  будет выдавать те же данные, что и в предыдущую сессию. например, /dev/urandom 
- квантовые данные
  невоспроизводимые данные из квантового источника
- каналы
  (описание пользовательских каналов. и описание их реализации на стороне zerovm.
  ошибки каналов, типы и т.д. большую часть можно взять из документа "channels.txt")
- запутанный канал
  каналы по которым передаются одни и те же данные из разных источников объединены в
  один условный канал, который может контролировать правильность передаваемых данных
  (при количестве каналов более 1) и восстанавливать данные (при количестве каналов 
  более 2). упрощенно алгоритм действия запутанного канала можно описать следующим 
  образом:
  1. при поступлении очередной порции данных от всех каналов составляющих запутанный
     канал, данные сравниваются между собой (ниже будет описан случай данных разного 
     размера) если есть хотя бы 2 канала с одинаковыми данными, данные считаются верными
     и используются, а каналы передавшие неверные данные отключаются. т.о. можно 
     запускать кластер на потенциально сбойном оборудовании
  2. для ускорения работы кластера можно не дожидаться данных из остальных источников 
     запутанного канала, если уже есть 2 канала приславшие совпадающие данные
  
  пока что предполагается, что размер пакета данных в запутанном канале всегда одинаков
  для всех составляющих его каналов. однако, можно легко убрать это ограничение если
  отсылать "отвалидированные" данные в том количестве в котором они уже есть
  
- пользовательская сессия
  все действия выполненные пользовательской программой от начала ее работы до конца. 
- модуль nacl (nexe, пользовательский код)
  модуль построенный в соответствиями с требованиями nacl и запускаемый или под управлением
  sel_ldr из nacl, или zerovm 
- доверенный код
  код проекта не предназначенный для выполнения под управлением zerovm
- опекаемый код (изолируемый код, untrusted side)
  код исполняемый под управлением zerovm 
- трамплин (батут, таблица прерываний)
  опекаемый код. занимает 64kb, начиная с адреса 0x10000 в пространстве пользователя.
  содержит адреса всех системных вызовов nacl и trap 
- пользовательское пространство (пользовательская адресация)
  32-битное пространство являющееся частью 64-битного пространства zerovm. занимает 4gb
  (не все пользовательское пространство доступно пользователю). содержит трамплин,
  пользовательский код и данные, пользовательскую кучу и стек. также к пользовательскому 
  пространству можно отнести 2 бампера предотвращающих выход за пределы 
  пользовательского пространства. бамперы недоступны пользователю и занимают 40gb + 64kb и 40gb
- пользовательская куча
  доступная на чтение и запись область из пространства пользователя, расположенная до стека.
  размер кучи определяется манифестом сессии
- пользовательский стек
  стек расположенный в пространстве пользователя (в самом конце пространства). занимает 16gb
- манифест (системный манифест)
  (часть текста можно взять из "manifest.txt")
- манифест (пользовательский манифест)
  (часть текста можно взять из "api.txt")
- кластер
  один или больше zerovm-ов работающих одновременно и связанных каналами
  при этом совокупность этих каналов представляют собой связный направленный граф
- однородные аппаратные средства
  компьютеры имеющие процессоры с одинаковой системой команд одинаково работающих
  на одинаковых данных. (если процессоры, например, возращают разные значения при
  вызове cpuid, то они не считаются одинаковыми). однако если программа не 
  использует различающиеся возможности процессоров, то компьютеры поддерживающие
  только требуемое программой подмножество инструкций, можно считать условно
  однородными.
- пользовательское окружение
  переменные окружения доступные пользователю через trap или через соответствующий
  параметр main(int argc, char **argv, char **envp) - envp. пользовательское окружение
  задается манифестом
- пользовательская командная строка
  задается манифестом. доступна через параметры main()
- имя узла
  argv[0] (см. "пользовательская командная строка"). задается манифестом.
- etag
  механизм контроля целостности данных. используется для данных передаваемых по каналам,
  пользовательской памяти. сейчас в качестве функции подсчета контрольных сумм
  применяется sha1. каждый канал связи завершается спецсимволом zvm_eof, 
  включающим в себя контрольную сумму (control tag, tag), что позволяет
  обнаруживать порчу данных при передаче


установка zerovm, nacl sdk e.t.c.
(пока что эта часть не готова, часть информации можно получить из README,
остальное будет добавлено позднее при участии группы litestack ops)

для работы zerovm требует наличия в пути следующих программ: ncval, ncval_stubout
предполагается, что обе программы взяты из проекта zerovm из папки lib/bin, где
находятся расширенные версии приспособленные для нужд гипервизора. можно использовать 
аналогичные программы из проекта google nacl, но в этом случае не гарантируется
детерминизм.

  ncval - валидатор для nacl nexe. нужен для проверки соответствия скомпилированного 
  пользователем кода требованиям безопасности nacl. как расширение, валидатор
  проверяет код и на нарушение детерминизма

  ncval_stubout - утилита для замены инструкций нарушающих требования nacl на 
  безопасные. запрещенные инструкции транслируются в hlt (останов). как расширение,
  инструкции нарушающие детерминизм заменяются nop (no operation).


начало работы (quick start)
(в этой главе описывается создание приложения для выполнения под управлением zerovm)


командная строка zerovm
(описание ключей запуска zerovm и примеры использования) 


отчеты:
пользовательская сессия может завершиться нормально или аварийно, в любом случае
zerovm возвращает отчет. единственный случай когда отчет не возвращается - zerovm
не успел стартовать nexe, ошибка произошла на этапе инициализации самого гипервизора.

пример отчета:
validator state = 0
user return code = 0
etag = fb28895f24c219518f87fbb53e1366192f92b91b
accounting = 0.01 0.00 536870912 0 0 0 2 35 0 0 0 0
exit state = ok

1. статус валидатора: 
   0 - пользовательский модуль прошел валидацию
   1 - ошибка валидации
   2 - другая ошибка
2. код возврата пользовательского модуля
3. контрольная сумма пользовательской памяти и пользовательских данных
4. учет ресурсов потраченных за сессию
   - системное время (время потраченное на ввод/вывод)
   - пользовательское время
   - выделенная пользователю память (в байтах)
   - пользовательский своп (не используется)
   - количество локальных чтений
   - количество локально прочитанных байт
   - количество локальных записей
   - количество локально записанных байт
   - количество удаленных чтений
   - количество удаленно прочитанных байт
   - количество удаленных записей
   - количество удаленно записанных байт
5. статус сессии. строка отличная от "ok" описывает ошибку которой
   завершилась сессия, и место ее возникновения (trusted/untrusted)

   примечание: триггеры на сигналы 24 и 25 устанавливаются самим
   zerovm и контролируют использование времени и дискового пространства.
   т.о. появление этих сигналов в доверенном коде - штатная ситуация


лог:
  всю техническую информацию о текущей сессии zerovm помещает в syslog
  (/var/log/syslog). при использовании расширенного логгирования и не 
  настроенном сислоге часть сообщений может пропасть. расширенное логгирование
  должно использоваться с осторожностью, оно может повлиять на скорость
  исполнения пользовательского кода. не рекомендуется использовать лог zerovm
  для отладки пользовательских программ.

  примечание: все временнЫе интервалы указаны в "абсолютном" времени. т.е.
  если процесс ждал час, а реально работал только секунду, в логе будет отражен
  весь час (в отчете, конечно, будет видна только секунда) 


код возврата:
  при завершении сессии гипервизор возращает код. ненулевой код означает
  ошибку. все коды ошибок соответствуют значениям <errno.h>
  

обработка сигналов:
  при получении сигнала zerovm уже не возращает управление пользовательскому
  модулю, закрывает каналы, подсчитывает контрольную сумму сессии,
  использованные ресурсы и выводит отчет, после чего завершается.


детерминизм:
(todo: сократить и переместить в бестиарий)
  zerovm реализует "слабую модель детерминизма", которая в отличие от "сильной" 
  позволяет использовать через обычные каналы квантовые источники данных (будет 
  описано позднее) и не работает на неоднородном аппаратном обеспечении. есть и 
  еще несколько ограничений, но не принципиальных, а технических, связаных с 
  использованием сторонних библиотек. после решения всех проблем планируется
  реализация "сильной модели детерминизма" (вообще, введение двух "детерминизмов"
  с громоздким описанием их отличий, вместо простого и ясного детерминизма,
  возникло из-за разногласий в команде о том, что считать детерминизмом)

  условия детерминизма (слабого):
  - пользовательская сессия (nexe run time) должна завершиться успешно
    (имеется ввиду отсутствие прерывания исполнения в результате возникновения
    сигнала в доверенном или опекаемом коде)
  - сессия должна выполняться на однородном "железе"
    (все компьютеры должны иметь одинаковые процессоры. под "одинаковыми" имеются
    ввиду процессоры одинаково обрабатывающие одинаковые данные. например, два
    процессора интел выдающие разную информацию по cpuid не будут считаться одинаковыми)
  - не должны использоваться "квантовые источники" данных
    (например, подключение /dev/urandom к пользовательской программе сломает детерминизм.
    правильным рещением будет использование специальной сессии zerovm, которая запишет
    необходимое количество данных из /dev/urandom в файл, а затем другая сессия 
    воспользуется уже сохраненными данными. вообще, "квантовые" данные легко превратить
    в обычные "фиксацией" и это можно делать параллельно с их обработкой)
  - должен использоваться механизм контроля данных - etag. в случае обнаружения ошибки в
    канале вся сессия должна быть рестартована. так же должны быть рестартованы и все
    зависимые сессии. в дальнейшем, для этого будут использоваться "запутанные" каналы,
    которые смогут не только обнаруживать порчу данных, но и "исправлять"  их (на самом
    деле, не столько исправлять сколько переключаться на источник выдающий верные данные).

    примечание: для того чтобы устранить "квантовые" источники и перейти к "сильной"
    модели детерминизма достаточно перед пользовательской сессией запустить специальную -
    превращающую квантовые данные в детерминированные. простая запись на локальном диске
    решает эту проблему. например, значения прочитанные из /dev/urandom могут быть сохранены
    в файл, а последующая и все остальные сессии будут читать уже сохраненные данные.
    эта логика может быть даже интегрирована в zerovm, однако поскольку количество данных
    для прочтения известно только пользовательской программе, гипервизору придется
    использовать ограничения канала, указанные в манифесте. таким образом, "квантовые"
    данные не могут быть учтены аккаунтингом точно. мало того, zerovm будет вынужден
    использовать дополнительное дисковое пространство для хранения "расквантованных"
    данных. кроме того, возможной проблемой является то, что время ожидания ввода/вывода
    не учитывается аккаунтингом. стоит учесть, что предлагаемое решение исключает
    вынесение логики за пределы пользовательской сессии, иначе говоря, пользователь
    не может превратить свою сессию в недетерминированную. все решения либо вычисляются
    из предопределенных данных воспроизводимым способом, либо принимаются до начала работы
    сессии.
    
область системных данных пользователя:
(предварительное описание. текущую реализацию можно посмотреть в api/zvm.h)
  по адресу 0xFEFFFFFC (4 байта перед стеком) находится указатель на struct UserManifest
  которая содержит следующие поля в указанном порядке:
  (*) -- адрес структуры можно передавать через стек. это более универсальный подход.
         изменение размеров и местоположения стека не будет требовать перекомпиляции
         пользовательских программ. однако, при этом не контролируется stack underflow
         в случае если производится чтение из стека.
  
  struct UserManifest
  1. указатель на кучу: (void*) 4bytes
  2. размер кучи: (uint32_t) 4bytes
  3. размер стека: (uint32_t) 4bytes
  4. количество каналов: (uint32_t) 4bytes
  5. указатель на массив структур каналов: (struct ZVMChannel*) (4)*48bytes
  6. указатель на окружение: устарело
  
  struct ZVMChannel
  1. массив ограничений ввода/вывода канала: (int64_t) IOLimitsCount*8bytes;
  2. размер канала: (int64_t) 8bytes
  3. тип канала: (int32_t) 4bytes
  4. указатель на имя канала: (char*) 4bytes
  
  IOLimitsCount == 4
  GetsLimit: разрешенное количество чтений
  GetSizeLimit: разрешенное для чтения количество байт
  PutsLimit: разрешенное количество записей
  PutSizeLimit: разрешенное для записей количество байт
  